══════════════════════════════════════════════════════════════
KOBOLDOS ALPHA v0.2.1 — DOKUMENTATION
══════════════════════════════════════════════════════════════

INHALTSVERZEICHNIS
──────────────────────────────────────────────────────────────
1. Uebersicht
2. Installation
3. GUI Bedienung
4. CLI Bedienung
5. Interaktive Session
6. Agent-System
7. Core Memory
8. Archival Memory
9. Memory Versionierung
10. Checkpoints
11. Skills
12. Secrets
13. Workflows
14. A2A Agent Cards
15. Konfiguration
16. HTTP API
17. Fehlerbehebung

──────────────────────────────────────────────────────────────
1. UEBERSICHT
──────────────────────────────────────────────────────────────

KoboldOS ist ein lokales KI-Betriebssystem fuer macOS. Es verbindet
lokale LLM-Modelle (via Ollama) mit einem leistungsfaehigen Agent-System,
das Tools autonom nutzen kann — Shell-Befehle, Datei-Operationen,
HTTP-Anfragen, AppleScript und mehr.

Architektur:
  - KoboldCore: Bibliothek mit Agent, Tools, Memory, Plugins
  - KoboldCLI: Kommandozeilen-Tool (16 Befehle)
  - KoboldOSControlPanel: macOS SwiftUI GUI App
  - Daemon: HTTP Server auf localhost:8080

LLM-Backend:
  - Primaer: Ollama (http://localhost:11434)
  - Fallback: llama.cpp (lokale GGUF Modelle)

──────────────────────────────────────────────────────────────
2. INSTALLATION
──────────────────────────────────────────────────────────────

Voraussetzungen:
  - macOS 14.0 (Sonoma) oder neuer
  - Ollama: brew install ollama
  - Mindestens ein Modell: ollama pull llama3.2

Installation:
  1. DMG oeffnen
  2. KoboldOS.app in /Applications ziehen
  3. App starten — Onboarding fuehrt durch Ersteinrichtung

Onboarding:
  - Sprache waehlen (15 Sprachen verfuegbar)
  - Persona erstellen (Name, Charakter)
  - Hauptnutzung waehlen (Coding, Research, Allgemein)
  - Modell auswaehlen

──────────────────────────────────────────────────────────────
3. GUI BEDIENUNG
──────────────────────────────────────────────────────────────

Die GUI bietet folgende Bereiche (Seitenleiste):

  Dashboard     Systemstatus, aktives Modell, Memory-Auslastung
  Chat          Nachrichten senden, Agent nutzt Tools automatisch
  Models        Modelle herunterladen, wechseln, loeschen
  Agents        Agent-Typen verwalten (General, Coder, Researcher...)
  Memory        Core Memory Bloecke bearbeiten + Archiv + Versionen
  Tasks         Wiederkehrende Aufgaben erstellen und verwalten
  Metrics       CPU, RAM, Tokens/s in Echtzeit
  Skills        Markdown-Skills importieren und aktivieren
  Secrets       API-Keys sicher im Keychain speichern
  Settings      Konfiguration in 12 Sektionen
  Team          Multi-Agent Uebersicht

Chat-Funktionen:
  - Nachricht eingeben und Enter druecken
  - Agent entscheidet selbst, welche Tools er nutzt
  - Thinking-Schritte werden als ausklappbare Sektion angezeigt
  - Tool-Aufrufe werden mit Ergebnis dargestellt
  - Confidence-Badge zeigt Sicherheit der Antwort
  - Mehrere Sessions moeglich (+ Button)

──────────────────────────────────────────────────────────────
4. CLI BEDIENUNG
──────────────────────────────────────────────────────────────

Das CLI-Tool `kobold` bietet 16 Befehle:

DAEMON
  kobold daemon [--port 8080]        Daemon starten
  kobold health                      Server-Status pruefen

MODELLE
  kobold model list                  Alle Modelle anzeigen
  kobold model set <name>            Aktives Modell wechseln
  kobold model status                Aktuelles Modell anzeigen

MEMORY
  kobold memory list [--json]        Alle Bloecke anzeigen
  kobold memory get <label>          Block-Inhalt anzeigen
  kobold memory set <label> <text>   Block-Inhalt setzen
  kobold memory delete <label>       Block loeschen
  kobold memory snapshot             Snapshot erstellen
  kobold memory log [--limit 10]     Versionshistorie
  kobold memory diff <id1> <id2>     Versionen vergleichen
  kobold memory rollback <id>        Auf Version zuruecksetzen

AUFGABEN
  kobold task list [--json]          Alle Tasks anzeigen
  kobold task create --name "..."    Task erstellen
  kobold task delete <id>            Task loeschen
  kobold task toggle <id>            Task aktivieren/deaktivieren

WORKFLOWS
  kobold workflow list               Alle Workflows anzeigen
  kobold workflow create --name "."  Workflow erstellen
  kobold workflow delete <id>        Workflow loeschen
  kobold workflow run <id>           Workflow ausfuehren

SKILLS
  kobold skill list                  Alle Skills anzeigen
  kobold skill import <pfad>         Skill importieren (.md)
  kobold skill toggle <name>         Skill aktivieren/deaktivieren
  kobold skill delete <name>         Skill loeschen

SECRETS
  kobold secret list                 Alle Keys anzeigen
  kobold secret set <key>            Secret setzen (verdeckt)
  kobold secret get <key> [--reveal] Secret anzeigen
  kobold secret delete <key>         Secret loeschen

KONFIGURATION
  kobold config list                 Alle Einstellungen
  kobold config get <key>            Einstellung lesen
  kobold config set <key> <value>    Einstellung setzen

CHECKPOINTS
  kobold checkpoint list             Alle Checkpoints
  kobold checkpoint resume <id>      Checkpoint fortsetzen
  kobold checkpoint delete <id>      Checkpoint loeschen

AGENT CARDS
  kobold card                        Eigene Agent Card anzeigen
  kobold card discover <url>         Andere Agent Card abrufen

WEITERE
  kobold metrics [--json] [--watch]  System-Metriken
  kobold safe-mode status|enable     Safe Mode
  kobold trace list|get <id>         Trace-Logs
  kobold history clear               Chat-Verlauf loeschen

──────────────────────────────────────────────────────────────
5. INTERAKTIVE SESSION
──────────────────────────────────────────────────────────────

`kobold` (ohne Subcommand) startet eine interaktive Chat-Session:

  $ kobold
  KoboldOS v0.2.1
  Verbunden mit Daemon auf Port 8080
  Neue Session: abc123

  you> Zeige mir die Dateien auf dem Desktop

    Thinking...
    shell: ls ~/Desktop
    12 Dateien gefunden
    Hier sind die Dateien auf deinem Desktop: ...
    [confidence: 0.95]

  you> /help
  you> /quit

Optionen:
  --port <n>        Daemon-Port (Standard: 8080)
  --token <t>       Auth-Token
  --agent <typ>     Agent-Typ (general, coder, researcher, planner)
  --session <id>    Bestehende Session laden
  --auto-daemon     Daemon automatisch starten (Standard: an)

Sessions werden automatisch gespeichert unter:
  ~/Library/Application Support/KoboldOS/cli_sessions/

──────────────────────────────────────────────────────────────
6. AGENT-SYSTEM
──────────────────────────────────────────────────────────────

Der Agent arbeitet in einer Schleife:
  1. Nachricht + System-Prompt + Memory an LLM senden
  2. LLM antwortet mit Tool-Aufruf oder Antwort
  3. Bei Tool-Aufruf: Tool ausfuehren, Ergebnis zurueck an LLM
  4. Wiederholen bis finale Antwort

Agent-Typen:
  general     — Allzweck-Agent, alle Tools verfuegbar
  coder       — Optimiert fuer Programmierung
  researcher  — Optimiert fuer Recherche
  planner     — Optimiert fuer Planung und Organisation
  instructor  — Optimiert fuer Erklaerungen

Verfuegbare Tools:
  shell              — Terminal-Befehle ausfuehren
  file_read          — Dateien lesen
  file_write         — Dateien schreiben
  file_list          — Verzeichnisse auflisten
  http_request       — HTTP-Anfragen senden
  applescript        — AppleScript ausfuehren
  notify_user        — Benachrichtigung senden
  response           — Finale Antwort an User
  delegate_task      — Sub-Agent starten
  calculator         — Berechnungen
  archival_search    — Archiv durchsuchen
  archival_insert    — In Archiv speichern

Confidence:
  Der Agent bewertet jede Antwort mit einem Konfidenz-Wert:
  - 0.8 - 1.0 (gruen): Hohe Sicherheit
  - 0.5 - 0.8 (gelb):  Mittlere Sicherheit
  - 0.0 - 0.5 (rot):   Niedrige Sicherheit, fragt nach

──────────────────────────────────────────────────────────────
7. CORE MEMORY
──────────────────────────────────────────────────────────────

Core Memory (Letta/MemGPT-Stil) sind beschriftete Textbloecke,
die in jeden System-Prompt kompiliert werden:

  persona        — Charakter und Verhalten des Agents
  human          — Infos ueber den Benutzer
  system_rules   — Systemregeln und Einschraenkungen
  short_term     — Kurzzeit-Notizen (wird archiviert bei >80%)
  knowledge      — Wissens-Bloecke (wird archiviert bei >80%)

Jeder Block hat ein Zeichenlimit (Standard: 2000).
Der Agent kann Memory-Bloecke selbst aktualisieren.

──────────────────────────────────────────────────────────────
8. ARCHIVAL MEMORY
──────────────────────────────────────────────────────────────

Wenn Core Memory Bloecke >80% ihres Limits erreichen, werden
die aeltesten 50% der Zeilen automatisch ins Archiv verschoben.

Der Agent kann mit zwei Tools auf das Archiv zugreifen:
  archival_memory_search — Suche nach Stichwort und/oder Label
  archival_memory_insert — Neuen Eintrag ins Archiv schreiben

Das Archiv wird gespeichert unter:
  ~/Library/Application Support/KoboldOS/Memory/archival_memory.json

In der GUI: Memory > Archiv-Sektion zeigt Statistiken und Eintraege.

──────────────────────────────────────────────────────────────
9. MEMORY VERSIONIERUNG
──────────────────────────────────────────────────────────────

Alle Core Memory Aenderungen werden versioniert (Git-Stil):

  - Automatischer Commit nach jeder Agent-Session
  - SHA-256 Hash als Versions-ID
  - Keine Duplikate (identische Inhalte werden uebersprungen)
  - Maximal 100 Versionen gespeichert

CLI-Befehle:
  kobold memory log              — Alle Versionen anzeigen
  kobold memory diff <id1> <id2> — Aenderungen vergleichen
  kobold memory rollback <id>    — Auf alte Version zuruecksetzen

In der GUI: Memory > Versionen-Tab mit Log und Rollback-Buttons.

──────────────────────────────────────────────────────────────
10. CHECKPOINTS
──────────────────────────────────────────────────────────────

Bei langen Agent-Aufgaben wird der Zustand automatisch an
Tool-Boundaries gespeichert (LangGraph-Stil):

  - Nachrichten-Verlauf
  - Schritt-Zaehler
  - Memory-Bloecke
  - Agent-Typ

Checkpoints werden gespeichert unter:
  ~/Library/Application Support/KoboldOS/checkpoints/

Fortsetzen:
  CLI:  kobold checkpoint resume <id>
  REPL: /resume <id>
  API:  POST /checkpoints/resume {"id": "..."}

Ctrl+C waehrend einer laufenden Aufgabe speichert automatisch
einen Checkpoint, sodass spaeter fortgesetzt werden kann.

──────────────────────────────────────────────────────────────
11. SKILLS
──────────────────────────────────────────────────────────────

Skills sind Markdown-Dateien die den System-Prompt erweitern:

  Speicherort: ~/Library/Application Support/KoboldOS/skills/

  Beispiel (python_expert.md):
    # Python Expert
    Du bist ein Python-Experte. Nutze immer Type Hints.
    Bevorzuge f-strings ueber .format().

Importieren:
  CLI: kobold skill import ~/skills/python_expert.md
  GUI: Skills > Importieren

Aktivierte Skills werden automatisch in den System-Prompt eingefuegt.

──────────────────────────────────────────────────────────────
12. SECRETS
──────────────────────────────────────────────────────────────

API-Keys und andere Geheimnisse werden sicher im macOS Keychain
gespeichert (nicht im Dateisystem):

  kobold secret set OPENAI_API_KEY     — Verdeckte Eingabe
  kobold secret get OPENAI_API_KEY     — Maskiert: sk-...****
  kobold secret get OPENAI_API_KEY --reveal  — Klartext
  kobold secret delete OPENAI_API_KEY  — Loeschen

In der GUI: Secrets-Ansicht mit Hinzufuegen/Loeschen/Anzeigen.

──────────────────────────────────────────────────────────────
13. WORKFLOWS
──────────────────────────────────────────────────────────────

Workflows sind Ketten von Agent-Aufrufen:

  Erstellen:
    kobold workflow create --name "Deploy" \
      --steps-file steps.json

  steps.json Format:
    [
      {"agent": "coder", "prompt": "Run tests"},
      {"agent": "general", "prompt": "Deploy to server"}
    ]

  Ausfuehren:
    kobold workflow run <id>

Die Schritte werden sequentiell ausgefuehrt, jeder mit eigenem
Agent-Typ und eigenem SSE-Stream.

──────────────────────────────────────────────────────────────
14. A2A AGENT CARDS
──────────────────────────────────────────────────────────────

KoboldOS implementiert den Google A2A Standard fuer Agent-Discovery:

  Eigene Card:    curl http://localhost:8080/.well-known/agent.json
  Andere finden:  kobold card discover http://other-agent:8080

Die Agent Card beschreibt:
  - Name und Version
  - Faehigkeiten (Streaming, Tools, Memory, Vision)
  - Unterstuetzte Agent-Typen
  - Verfuegbare Endpoints
  - Authentifizierungsmethode

Der /.well-known/agent.json Endpoint ist oeffentlich (kein Auth).

──────────────────────────────────────────────────────────────
15. KONFIGURATION
──────────────────────────────────────────────────────────────

Alle Einstellungen werden in UserDefaults gespeichert:

  kobold config list               — Alle anzeigen
  kobold config get kobold.port    — Einzelne lesen
  kobold config set kobold.port 9090 — Setzen

Wichtige Keys:
  kobold.port              — Daemon-Port (Standard: 8080)
  kobold.model             — Aktives Modell
  kobold.language          — Sprache (de, en, fr, es, it, ...)
  kobold.hasOnboarded      — Onboarding abgeschlossen
  kobold.autoStart         — Auto-Start bei Login
  kobold.maxSteps          — Maximale Agent-Schritte

──────────────────────────────────────────────────────────────
16. HTTP API
──────────────────────────────────────────────────────────────

Alle Endpoints erfordern Bearer-Token-Auth (Standard: kobold-secret):
  Authorization: Bearer kobold-secret

Ausnahme: /.well-known/agent.json (oeffentlich)

ENDPOINTS:

  GET  /health
    Antwort: {"status": "ok", "version": "0.2.1", ...}

  POST /agent
    Body: {"message": "...", "agent_type": "general"}
    Antwort: {"steps": [...], "finalAnswer": "..."}

  POST /agent/stream
    Body: {"message": "...", "agent_type": "general"}
    Antwort: SSE Stream mit Events:
      data: {"type": "think", "content": "..."}
      data: {"type": "toolCall", "tool": "shell", "content": "ls"}
      data: {"type": "toolResult", "content": "...", "success": "true"}
      data: {"type": "finalAnswer", "content": "...", "confidence": "0.9"}
      event: done

  POST /chat
    Body: {"message": "..."}
    Antwort: {"response": "..."}

  GET  /models
    Antwort: {"models": [...], "active": "llama3.2"}

  GET  /metrics
    Antwort: {"cpu": 45.2, "memory": 8192, ...}

  GET  /memory
    Antwort: {"blocks": [{"label": "persona", "content": "...", ...}]}

  POST /memory/update
    Body: {"label": "persona", "content": "Neuer Inhalt"}

  GET  /checkpoints
    Antwort: {"checkpoints": [...]}

  POST /checkpoints/resume
    Body: {"id": "..."}
    Antwort: SSE Stream

  GET  /memory/versions
    Antwort: {"versions": [...]}

  GET  /.well-known/agent.json
    Antwort: Agent Card JSON (kein Auth)

──────────────────────────────────────────────────────────────
17. FEHLERBEHEBUNG
──────────────────────────────────────────────────────────────

DAEMON STARTET NICHT
  - Port belegt? lsof -i :8080 && kill <PID>
  - Ollama laeuft? ollama serve
  - Logs pruefen: kobold daemon --port 8080

GUI VERBINDET NICHT
  - Daemon laeuft? kobold health
  - Richtiger Port? Standard: 8080
  - Firewall? localhost muss erlaubt sein

KEIN MODELL VERFUEGBAR
  - ollama list → Modelle pruefen
  - ollama pull llama3.2 → Modell herunterladen
  - kobold model list → Verfuegbare Modelle

AGENT ANTWORTET NICHT
  - Modell geladen? kobold model status
  - Safe Mode aktiv? kobold safe-mode status
  - Logs: kobold trace list

MEMORY VOLL
  - Archivierung passiert automatisch bei >80%
  - Manuell: kobold memory delete <label>
  - Archiv pruefen: GUI > Memory > Archiv

SESSION VERLOREN
  - Sessions sind unter ~/Library/Application Support/KoboldOS/cli_sessions/
  - kobold (REPL) → /list zeigt alle Sessions
  - Checkpoints: kobold checkpoint list

══════════════════════════════════════════════════════════════
KoboldOS Alpha v0.2.1 | Build 2026-02-22
Copyright (c) 2026 KoboldOS. Alle Rechte vorbehalten.
══════════════════════════════════════════════════════════════